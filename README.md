# ECDSA NodeA secure blockchain-inspired transaction system using ECDSA signatures for authentication.## Features- Digital signature verification using ECDSA (secp256k1)- Nonce-based replay attack prevention- Persistent state management with automatic debounced saves- Client-side transaction signing- Address validation and balance management- Message hash verification for transaction integrity## Security Features- **Digital Signatures**: All transactions must be signed with the sender's private key- **Nonce System**: Prevents replay attacks by requiring sequential nonces (current nonce + 1)- **Message Hashing**: Transaction integrity verification using Keccak-256- **Address Recovery**: Automatic sender verification from signature using ECDSA public key recovery- **Address Validation**: Ethereum address format validation (0x + 40 hex characters)- **Self-Transfer Prevention**: Cannot transfer funds to the same address- **Amount Validation**: Positive integers only, capped at 1,000,000## Setup### Server```bashcd servernpm installnpm run dev```Server runs on port 3042 (configurable via PORT environment variable).### Client```bashcd clientnpm installnpm run dev```## API Endpoints### `GET /balance/:address`Get the current balance for an address.**Response:**```json{  "balance": 100}```### `GET /nonce/:address`Get the current nonce for an address.**Response:**```json{  "nonce": 5}```### `POST /send`Submit a signed transaction.**Request Body:**```json{  "message": {    "sender": "0x...",    "recipient": "0x...",    "amount": 10,    "nonce": 6  },  "signature": "0x...",  "messageHash": "0x..."}```**Response:**```json{  "balance": 90,  "newNonce": 6,  "recipient": {    "address": "0x...",    "newBalance": 110  }}```## Transaction Flow1. Client fetches current nonce from server (`GET /nonce/:address`)2. Client creates transaction message with `nonce = currentNonce + 1`3. Client computes Keccak-256 hash of the message4. Client signs the message hash with private key5. Client sends transaction to server with message, signature, and hash6. Server validates address formats7. Server verifies nonce matches expected value8. Server recomputes message hash to verify integrity9. Server recovers public key from signature and verifies it matches sender10. Server checks sufficient funds11. Server processes transaction and updates balances12. Server increments sender's nonce13. Server persists state to storage.json (debounced)## Error Codes- `INVALID_ADDRESS` - Invalid Ethereum address format- `INVALID_SIGNATURE` - Signature verification failed or missing required fields- `INVALID_NONCE` - Nonce mismatch (expected vs received)- `INVALID_HASH` - Message hash verification failed- `INSUFFICIENT_FUNDS` - Sender doesn't have enough balance- `INVALID_AMOUNT` - Amount must be a positive integer â‰¤ 1,000,000- `SELF_TRANSFER` - Cannot transfer to the same address- `INTERNAL_ERROR` - Server-side error during processing## StorageBalances and nonces are persisted to `storage.json` with automatic debounced saves (1 second delay). The storage file is loaded on server startup, and if not found or corrupted, the server starts with empty state.## Technologies- **Server**: Express.js, TypeScript- **Client**: React, TypeScript, Vite- **Crypto**: @noble/secp256k1, @noble/hashes- **Signature Scheme**: ECDSA with secp256k1 curve- **Hash Function**: Keccak-256